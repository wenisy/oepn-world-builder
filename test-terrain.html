<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>地形生成测试</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>地形生成测试</h2>
        <p>使用WASD移动，空格跳跃，鼠标控制视角</p>
        <p>当前位置: <span id="position">0, 0, 0</span></p>
        <p>当前区块: <span id="chunk">0, 0, 0</span></p>
        <p>FPS: <span id="fps">0</span></p>
    </div>
    <div id="controls">
        <button id="regenerate">重新生成地形</button>
        <button id="toggle-wireframe">切换线框模式</button>
    </div>
    <canvas id="game-canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
        import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/PointerLockControls.js';

        // 噪声生成器
        class NoiseGenerator {
            constructor(seed = Math.random() * 10000) {
                // 设置随机种子
                this.seed = seed;
                
                // 初始化置换表
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                
                // 使用种子初始化置换表
                this.initPermutationTable();
                
                // Simplex噪声的梯度向量
                this.grad3 = [
                    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
                ];
                
                // Simplex噪声的常量
                this.F2 = 0.5 * (Math.sqrt(3) - 1);
                this.G2 = (3 - Math.sqrt(3)) / 6;
                this.F3 = 1 / 3;
                this.G3 = 1 / 6;
            }
            
            // 初始化置换表
            initPermutationTable() {
                // 使用线性同余法生成伪随机数
                const lcg = (a) => (a * 1664525 + 1013904223) % 4294967296;
                
                // 初始化基础置换表
                let seed = Math.floor(this.seed);
                for (let i = 0; i < 256; i++) {
                    seed = lcg(seed);
                    this.perm[i] = seed % 256;
                }
                
                // 复制到后半部分
                for (let i = 0; i < 256; i++) {
                    this.perm[i + 256] = this.perm[i];
                    this.permMod12[i] = this.perm[i] % 12;
                    this.permMod12[i + 256] = this.permMod12[i];
                }
            }
            
            // 生成2D Simplex噪声
            simplex2D(x, y) {
                // 噪声贡献
                let n0, n1, n2;
                
                // 将输入坐标偏移到斜坐标系
                const s = (x + y) * this.F2;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                
                // 计算单元格原点的偏移
                const t = (i + j) * this.G2;
                const X0 = i - t;
                const Y0 = j - t;
                
                // 计算相对于单元格原点的坐标
                const x0 = x - X0;
                const y0 = y - Y0;
                
                // 确定单元格中的三角形
                let i1, j1;
                if (x0 > y0) {
                    i1 = 1;
                    j1 = 0;
                } else {
                    i1 = 0;
                    j1 = 1;
                }
                
                // 计算三角形顶点的坐标
                const x1 = x0 - i1 + this.G2;
                const y1 = y0 - j1 + this.G2;
                const x2 = x0 - 1 + 2 * this.G2;
                const y2 = y0 - 1 + 2 * this.G2;
                
                // 计算哈希值
                const ii = i & 255;
                const jj = j & 255;
                
                // 计算梯度贡献
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) {
                    n0 = 0;
                } else {
                    t0 *= t0;
                    const gi0 = this.permMod12[ii + this.perm[jj]];
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) {
                    n1 = 0;
                } else {
                    t1 *= t1;
                    const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) {
                    n2 = 0;
                } else {
                    t2 *= t2;
                    const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                
                // 缩放到[-1,1]范围
                return 70 * (n0 + n1 + n2);
            }
            
            // 生成分形布朗运动（FBM）噪声
            fbm(x, y, z = 0, octaves = 6, persistence = 0.5, lacunarity = 2.0) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;
                
                // 累加不同频率的噪声
                for (let i = 0; i < octaves; i++) {
                    total += this.simplex2D(x * frequency, y * frequency) * amplitude;
                    
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                
                // 归一化到[-1,1]范围
                return total / maxValue;
            }
            
            // 生成地形高度图
            generateTerrainHeight(x, z, options = {}) {
                // 默认选项
                const {
                    scale = 100,
                    heightScale = 64,
                    baseHeight = 64,
                    octaves = 6,
                    persistence = 0.5,
                    lacunarity = 2.0,
                    biomeScale = 200
                } = options;
                
                // 生成基础地形
                const nx = x / scale;
                const nz = z / scale;
                const baseNoise = this.fbm(nx, nz, 0, octaves, persistence, lacunarity);
                
                // 生成生物群系噪声
                const biomeNoise = this.simplex2D(x / biomeScale, z / biomeScale);
                
                // 根据生物群系调整地形
                let height = baseHeight;
                
                // 平原
                if (biomeNoise < -0.4) {
                    height += baseNoise * heightScale * 0.3;
                }
                // 丘陵
                else if (biomeNoise < 0) {
                    height += baseNoise * heightScale * 0.7;
                }
                // 山地
                else if (biomeNoise < 0.4) {
                    height += baseNoise * heightScale * 1.2;
                }
                // 高山
                else {
                    height += baseNoise * heightScale * 1.8;
                    
                    // 添加尖峰
                    const mountainNoise = this.simplex2D(nx * 2, nz * 2);
                    if (mountainNoise > 0.7) {
                        height += mountainNoise * heightScale * 0.5;
                    }
                }
                
                return Math.floor(height);
            }
            
            // 计算点积
            dot(g, x, y, z = 0) {
                return g[0] * x + g[1] * y + g[2] * z;
            }
        }

        // 主应用类
        class TerrainApp {
            constructor() {
                // 初始化场景
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
                
                // 初始化相机
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 100, 0);
                
                // 初始化渲染器
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('game-canvas'),
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                
                // 添加光源
                this.setupLights();
                
                // 初始化控制器
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // 初始化噪声生成器
                this.noiseGenerator = new NoiseGenerator(Math.random() * 10000);
                
                // 地形参数
                this.terrainParams = {
                    size: 100, // 地形大小
                    resolution: 1, // 分辨率
                    maxHeight: 100, // 最大高度
                    wireframe: false // 线框模式
                };
                
                // 地形网格
                this.terrain = null;
                
                // 生成地形
                this.generateTerrain();
                
                // 添加事件监听器
                window.addEventListener('resize', this.onWindowResize.bind(this));
                document.getElementById('regenerate').addEventListener('click', this.regenerateTerrain.bind(this));
                document.getElementById('toggle-wireframe').addEventListener('click', this.toggleWireframe.bind(this));
                
                // 性能监控
                this.stats = {
                    fps: 0,
                    frameCount: 0,
                    lastTime: performance.now()
                };
                
                // 开始动画循环
                this.animate();
            }
            
            // 设置光照
            setupLights() {
                // 环境光
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                // 定向光（模拟太阳）
                const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                sunLight.position.set(100, 100, 50);
                sunLight.castShadow = true;
                
                // 设置阴影参数
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.near = 0.5;
                sunLight.shadow.camera.far = 500;
                sunLight.shadow.camera.left = -100;
                sunLight.shadow.camera.right = 100;
                sunLight.shadow.camera.top = 100;
                sunLight.shadow.camera.bottom = -100;
                
                this.scene.add(sunLight);
            }
            
            // 生成地形
            generateTerrain() {
                // 如果已经有地形，先移除
                if (this.terrain) {
                    this.scene.remove(this.terrain);
                    this.terrain.geometry.dispose();
                    this.terrain.material.dispose();
                }
                
                // 创建地形几何体
                const geometry = new THREE.PlaneGeometry(
                    this.terrainParams.size * 2,
                    this.terrainParams.size * 2,
                    this.terrainParams.size / this.terrainParams.resolution,
                    this.terrainParams.size / this.terrainParams.resolution
                );
                
                // 旋转几何体使其水平
                geometry.rotateX(-Math.PI / 2);
                
                // 获取顶点
                const vertices = geometry.attributes.position.array;
                
                // 应用噪声生成高度
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const z = vertices[i + 2];
                    
                    // 生成高度
                    const height = this.noiseGenerator.generateTerrainHeight(x, z, {
                        scale: 100,
                        heightScale: 40,
                        baseHeight: 0, // 这里使用0作为基础高度，因为我们直接设置顶点高度
                        octaves: 6,
                        persistence: 0.5,
                        lacunarity: 2.0,
                        biomeScale: 200
                    });
                    
                    // 设置顶点高度
                    vertices[i + 1] = height;
                }
                
                // 更新法线
                geometry.computeVertexNormals();
                
                // 创建材质
                const material = new THREE.MeshStandardMaterial({
                    color: 0x3d8c40,
                    wireframe: this.terrainParams.wireframe,
                    flatShading: true
                });
                
                // 创建网格
                this.terrain = new THREE.Mesh(geometry, material);
                this.terrain.receiveShadow = true;
                
                // 添加到场景
                this.scene.add(this.terrain);
                
                // 将相机移动到地形上方
                this.camera.position.set(0, 100, 0);
                this.controls.target.set(0, 0, 0);
            }
            
            // 重新生成地形
            regenerateTerrain() {
                this.noiseGenerator = new NoiseGenerator(Math.random() * 10000);
                this.generateTerrain();
            }
            
            // 切换线框模式
            toggleWireframe() {
                if (this.terrain) {
                    this.terrainParams.wireframe = !this.terrainParams.wireframe;
                    this.terrain.material.wireframe = this.terrainParams.wireframe;
                }
            }
            
            // 处理窗口大小变化
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // 动画循环
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                // 更新控制器
                this.controls.update();
                
                // 更新FPS计数
                const now = performance.now();
                this.stats.frameCount++;
                
                if (now - this.stats.lastTime >= 1000) {
                    this.stats.fps = this.stats.frameCount;
                    this.stats.frameCount = 0;
                    this.stats.lastTime = now;
                    
                    // 更新UI
                    document.getElementById('fps').textContent = this.stats.fps;
                }
                
                // 更新位置信息
                document.getElementById('position').textContent = `${Math.floor(this.camera.position.x)}, ${Math.floor(this.camera.position.y)}, ${Math.floor(this.camera.position.z)}`;
                document.getElementById('chunk').textContent = `${Math.floor(this.camera.position.x / 16)}, ${Math.floor(this.camera.position.y / 16)}, ${Math.floor(this.camera.position.z / 16)}`;
                
                // 渲染场景
                this.renderer.render(this.scene, this.camera);
            }
        }

        // 创建应用实例
        const app = new TerrainApp();
    </script>
</body>
</html>
